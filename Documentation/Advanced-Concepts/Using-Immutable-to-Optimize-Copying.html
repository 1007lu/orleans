<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Using Immutable&lt;T&gt; to Optimize Copying | Microsoft Orleans Website </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Using Immutable&lt;T&gt; to Optimize Copying | Microsoft Orleans Website ">
    <meta name="generator" content="docfx 2.10.2.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="docfx:rel" content="../../">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../Images/logo-light.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="using-immutablet-to-optimize-copying">Using <code>Immutable&lt;T&gt;</code> to Optimize Copying</h1>
              
<p>Orleans has a feature that can be used to avoid some of the overhead associated with serializing request messages. This note starts with a general description of how serialization works, and then explains how to use the new feature.</p>
<h2 id="serialization-in-orleans">Serialization in Orleans</h2>
<p>When a grain method is invoked, the Orleans runtime makes a deep copy of the method arguments and forms the request out of the copies. This protects against the calling code modifying the argument objects before the data is passed to the called grain.</p>
<p>If the called grain is on a different silo, then the copies are eventually serialized into a byte stream and sent over the network to the target silo, where they are deserialized back into objects. If the called grain is on the same silo, then the copies are handed directly to the called method.</p>
<p>Return values are handled the same way: first copied, then possibly serialized and deserialized.</p>
<p>Note that all 3 processes, copying, serializing, and deserializing, respect object identity. In other words, if you pass a list that has the same object in it twice, on the receiving side you&#39;ll get a list with the same object in it twice, rather than with two objects with the same values in them.</p>
<p>Also note that Orleans doesn&#39;t use the .NET serializer or the data contract serializer. Orleans uses a mix of hand-crafted code for common system types (collections, primitives, and a few others) and generated code for application types. If a type with neither a hand-crafted or generated serializer is encountered, Orleans will use the configured fallback serializer, but this should be a rare occurrence. We try to avoid this because the .NET serializer is significantly slower than the Orleans serializer, and creates significantly larger messages.</p>
<h2 id="optimizing-copying">Optimizing Copying</h2>
<p>In many cases, the deep copying is unnecessary. For instance, a possible scenario is a web front-end that receives a byte array from its client and passes that request, including the byte array, on to a grain for processing. The front-end process doesn&#39;t do anything with the array once it has passed it on to the grain; in particular, it doesn&#39;t reuse the array to receive a future request. Inside the grain, the byte array is parsed to fetch the input data, but not modified. The grain returns another byte array that it has created to get passed back to the web client; it discards the array as soon as it returns it. The web front-end passes the result byte array back to its client, without modification.</p>
<p> In such a scenario, there is no need to copy either the request or response byte arrays. Unfortunately, the Orleans runtime can&#39;t figure this out by itself, since it can&#39;t tell whether or not the arrays are modified later on by the web front-end or by the grain. In the best of all possible worlds, we&#39;d have some sort of .NET mechanism for indicating that a value is no longer modified; lacking that, we&#39;ve added Orleans-specific mechanisms for this: the <code>Immutable&lt;T&gt;</code> wrapper class and the <code>[Immutable]</code> attribute.</p>
<h2 id="immutablet"><code>Immutable&lt;T&gt;</code></h2>
<p>The <code>Orleans.Concurrency.Immutable&lt;T&gt;</code> wrapper class is used to indicate that a value may be considered immutable; that is, the underlying value will not be modified, so no copying is required for safe sharing. Note that using <code>Immutable&lt;T&gt;</code> implies that neither the provider of the value nor the recipient of the value will modify it in the future; it is not a one-sided commitment, but rather a mutual dual-side commitment.</p>
<h3 id="using-immutablet">Using Immutable<t></t></h3>
<p>Using <code>Immutable&lt;T&gt;</code> is simple: in your grain interface, instead of passing <code>T</code>, pass <code>Immutable&lt;T&gt;</code>. For instance, in the above described scenario, the grain method that was:</p>
<pre><code class="lang-csharp">Task&lt;byte[]&gt; ProcessRequest(byte[] request);
</code></pre><p>Becomes:</p>
<pre><code class="lang-csharp">Task&lt;Immutable&lt;byte[]&gt;&gt; ProcessRequest(Immutable&lt;byte[]&gt; request);
</code></pre><p>To create an <code>Immutable&lt;T&gt;</code>, simply use the constructor:</p>
<pre><code class="lang-csharp">Immutable&lt;byte[]&gt; immutable = new Immutable&lt;byte[]&gt;(buffer);
</code></pre><p> And to get the value inside the immutable, use the <code>.Value</code> property:</p>
<pre><code class="lang-csharp">byte[] buffer = immutable.Value;
</code></pre><h2 id="the-immutable-attribute">The <code>[Immutable]</code> attribute</h2>
<p>For user-defined types, the <code>[Orleans.Concurrency.Immutable]</code> attribute can be added to the type. This instructs Orleans&#39; code generator to avoid copying instances of this type.</p>
<h2 id="immutability-in-orleans">Immutability in Orleans</h2>
<p>For Orleans&#39; purposes, immutability is a rather strict statement: the contents of the data item will not be modified in any way that could change the item&#39;s semantic meaning, or that would interfere with another thread simultaneously accessing the item. The safest way to ensure this is to simply not modify the item at all: bitwise immutability, rather than logical immutability.</p>
<p>In some cases it is safe to relax this to logical immutability, but care must be taken to ensure that the mutating code is properly thread-safe; because dealing with multithreading is complex, and uncommon in an Orleans context, we strongly recommend against this approach and recommend sticking to bitwise immutability.</p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Advanced-Concepts/Using-Immutable-to-Optimize-Copying.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2016 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
